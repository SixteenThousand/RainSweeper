/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Board.js":
/*!**********************!*\
  !*** ./src/Board.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Cell_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell.js */ \"./src/Cell.js\");\n\r\n\r\nconst SVGNS = \"http://www.w3.org/2000/svg\";\r\nconst ADJ_TOL = 0.4;\r\n\t// the tolerance for two vertices of different cells to be considered\r\n\t// \"approximately the same\", divided by the side length of the bounding\r\n\t// shape of a cell\r\n\r\n\r\nclass CellGroup {\r\n\t/*\r\n\t\tOrganises a group of cells that can then be replicated in a grid\r\n\t\tformation to form the board. Specifically, it organises:\r\n\t\t\t- drawing the cells onto an svg canvas\r\n\t\t\t- determining which cells are adjacnent to each other\r\n\t*/\r\n\t\r\n\tconstructor(cellsInfo,dx,dy,groupPadding) {\r\n\t\t/*\r\n\t\t\t++++++++++++ parameters ++++++++++++\r\n\t\t\t(Number/int[][]) cellsInfo: information about each cell in the\r\n\t\t\t\tgroup. Specifically, each entry in the array is an object with \r\n\t\t\t\tproperties:\r\n\t\t\t\t\t- x: the x-coord of the top-leftmost vertex of the bounding shape\r\n\t\t\t\t\t- y: the y-coord of the top-leftmost vertex of the bounding shape\r\n\t\t\t\t\t- angle: the angle the baseline of the bounding shape makes with the \r\n\t\t\t\t\t\thorizontal\r\n\t\t\t\t\t- numSides: the number of sides of the cell\r\n\t\t\t\tin that order.\r\n\t\t\t\tNote that the coordinates are measured relative to the\r\n\t\t\t\tcoordinates of the top-leftmost vertex of the top-leftmost\r\n\t\t\t\tcell in the group, and in units of the side length of the bounding shape\r\n\t\t\t\tof a cell.\r\n\t\t\t(Number) dx,dy: the difference in x/y-coordinates between\r\n\t\t\t\tthe top-leftmost and bottom-rightmost vertices of the cells\r\n\t\t\t\twhen rendered\r\n\t\t\t(Number) groupPadding: dx,dy above define a rectangle used to position\r\n\t\t\t\tthe cell group. padding is the padding need around this rectangle\r\n\t\t\t\tneeded to fit all of the cell shapes onto a screen\r\n\t\t*/\r\n\t\tthis.cellsInfo = cellsInfo;\r\n\t\tthis.numCells = cellsInfo.length;\r\n\t\tthis.dx = dx;\r\n\t\tthis.dy = dy;\r\n\t\tthis.groupPadding = groupPadding;\r\n\t}\r\n\t\r\n\tdraw(svgcanvas,x,y,boundSide) {\r\n\t\t/*\r\n\t\t\tcreates a copy of the cells that this CellGroup represents in\r\n\t\t\tthe given svg element at given coordinates\r\n\t\t\t(svg element) svgcanvas: the svg element\r\n\t\t\t(Number/int) x,y: the coordinates of the top-leftmost vertex of the\r\n\t\t\t\ttop-leftmost cell in this CellGroup\r\n\t\t\t(Number) boundSide: the boundSide-length of the bounding shape of each cell\r\n\t\t*/\r\n\t\tlet cells = [];\r\n\t\tlet tmpAngle;\r\n\t\tfor(let info of this.cellsInfo) {\r\n\t\t\ttmpAngle = Math.PI*(0.5-(1/info.numSides));\r\n\t\t\tcells[cells.length] = new _Cell_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].RegularCell(\r\n\t\t\t\tsvgcanvas,\r\n\t\t\t\tx + boundSide * info.x,\r\n\t\t\t\ty + boundSide * info.y,\r\n\t\t\t\tinfo.angle,\r\n\t\t\t\tinfo.numSides,\r\n\t\t\t\tboundSide\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn cells;\r\n\t}\r\n}\r\n\r\n\r\nclass Board {\r\n\tconstructor(svgcanvas,boundSide,groupType,numRows,numCols,totalBombs) {\r\n\t\t/*\r\n\t\t\t(CellGroup) groupType: the type of cell group being used to\r\n\t\t\t\tcontruct this board\r\n\t\t\t(Number/int) numRows,numCols: the number of rows/columns in the\r\n\t\t\t\tgrid of cell groups\r\n\t\t\t(Number/int) totalBombs: the total number of bombs to be \r\n\t\t\t\tplaced on the board\r\n\t\t*/\r\n\t\tthis.cells = [];\r\n\t\tthis.boundSide = boundSide;\r\n\t\tthis.numCellsInGroup = groupType.numCells;\r\n\t\tlet x0 = groupType.groupPadding * boundSide;\r\n\t\tlet y0 = groupType.groupPadding * boundSide;\r\n\t\tfor(let i=0; i<numRows; ++i) {\r\n\t\t\tfor(let j=0;j<numCols;++j) {\r\n\t\t\t\tthis.cells = this.cells.concat(\r\n\t\t\t\t\tgroupType.draw(\r\n\t\t\t\t\t\tsvgcanvas,\r\n\t\t\t\t\t\tx0+j*groupType.dx*boundSide,\r\n\t\t\t\t\t\ty0+i*groupType.dy*boundSide,\r\n\t\t\t\t\t\tboundSide\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.height = boundSide * (\r\n\t\t\tgroupType.dy * numRows +\r\n\t\t\tgroupType.groupPadding * 2\r\n\t\t);\r\n\t\tthis.width = boundSide * (\r\n\t\t\tgroupType.dx * numCols +\r\n\t\t\tgroupType.groupPadding * 2\r\n\t\t);\r\n\t\t\r\n\t\tthis.numBombs = totalBombs;\r\n\t\t\r\n\t\t// dealing with the first click\r\n\t\tdocument.addEventListener(\r\n\t\t\t\"click\",\r\n\t\t\tevent => {\r\n\t\t\t\tlet bombIndices = [];\r\n\t\t\t\tlet cellIndices = [...this.cells.keys()];\r\n\t\t\t\t// remove the cell that was clicked on first\r\n\t\t\t\t// so it doesn't become a bomb\r\n\t\t\t\tlet firstCellIndex = 0;\r\n\t\t\t\twhile(firstCellIndex < cellIndices.length &&\r\n\t\t\t\t\tthis.cells[firstCellIndex].cellShape !== event.target) {\r\n\t\t\t\t\t++firstCellIndex;\r\n\t\t\t\t}\r\n\t\t\t\tcellIndices.splice(firstCellIndex,1);\r\n\t\t\t\tlet bombIndex;\r\n\t\t\t\tfor(let j=0; j<totalBombs; ++j) {\r\n\t\t\t\t\tbombIndex = Math.floor(cellIndices.length*Math.random());\r\n\t\t\t\t\tbombIndices.push(cellIndices[bombIndex]);\r\n\t\t\t\t\tcellIndices.splice(bombIndex,1);\r\n\t\t\t\t}\r\n\t\t\t\tfor(let i of bombIndices) {\r\n\t\t\t\t\tthis.cells[i].setBomb();\r\n\t\t\t\t\tfor(let j=0; j<this.cells.length; ++j) {\r\n\t\t\t\t\t\tif(j === i) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(this.areAdjacent(i,j)) {\r\n\t\t\t\t\t\t\tthis.cells[j].incNumAdjBombs();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// this.cells[firstCellIndex].reveal();\r\n\t\t\t},\r\n\t\t\t{once:true,capture:true}\r\n\t\t);\r\n\t}\r\n\t\r\n\tapproxEqual(vertex1,vertex2) {\r\n\t\t// determines whether two given points are the same,\r\n\t\t// \tup to a tolerance of ADJ_TOL times the side length of the bounding\r\n\t\t// shape of a cell\r\n\t\tlet [x1,y1] = vertex1.split(\",\").map(parseFloat);\r\n\t\tlet [x2,y2] = vertex2.split(\",\").map(parseFloat);\r\n\t\treturn (x1-x2)**2 + (y1-y2)**2 < ADJ_TOL*this.boundSide;\r\n\t}\r\n\t\r\n\tareAdjacent(index1,index2) {\r\n\t\t// calculates whether the cells at indices index1,index2 in this.cells\r\n\t\t// are adjacent or not; i.e. whether they share a cell border\r\n\t\tif(this.cells[index1] === this.cells[index2]) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// caculate which cellgroups these two cells are part of\r\n\t\tlet numCellsInRow = this.numCols * this.numCellsInGroup;\r\n\t\tlet row1 = Math.trunc(index1 / numCellsInRow);\r\n\t\tlet row2 = Math.trunc(index2 / numCellsInRow);\r\n\t\tlet col1 = Math.trunc((index1 % numCellsInRow) / \r\n\t\t\tthis.numCellsInGroup);\r\n\t\tlet col2 = Math.trunc((index2 % numCellsInRow) / \r\n\t\t\tthis.numCellsInGroup);\r\n\t\tif(Math.abs(row1-row2) > 1 || Math.abs(col1-col2) > 1) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// calculate whether the two cells have any vertices in common\r\n\t\tlet vertices1 = this.cells[index1].boundShape.getAttribute(\"points\").split(\" \");\r\n\t\tlet vertices2 = this.cells[index2].boundShape.getAttribute(\"points\").split(\" \");\r\n\t\tfor(let i=0; i<vertices1.length; ++i) {\r\n\t\t\tfor(let j=0; j<vertices2.length; ++j) {\r\n\t\t\t\tif(this.approxEqual(vertices1[i],vertices2[j])) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tisWon() {\r\n\t\t// determines whether the player has won the game when it is called\r\n\t\tfor(let cell of this.cells) {\r\n\t\t\tif(!cell.isRevealed && !cell.isBomb)\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\nconst exports = {\r\n\t\"CellGroup\":CellGroup,\r\n\t\"Board\":Board,\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);\r\n\n\n//# sourceURL=webpack:///./src/Board.js?");

/***/ }),

/***/ "./src/Cell.js":
/*!*********************!*\
  !*** ./src/Cell.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// cell background \r\nconst UNREVEALED_COLOUR = \"white\";\r\n// \tthe padding to be put around each cell\r\n// (as a fraction of the bounding shape's side length)\r\nconst PADDING = 0.07;\r\nconst PADDING_COLOUR = \"transparent\";\r\nconst NO_BOMB_BACKGROUND = \"#00ffff\";\r\nconst BOMB_OPACITY = \"0.2\";\r\n\r\n// the label (showing the # of adjacent bombs) \r\nconst LABEL_COLOURS = [\r\n\t\"#00ffff\",\r\n\t\"#0000ff\",\r\n\t\"#00ff00\",\r\n\t\"#ff0000\",\r\n\t\"#00ffff\",\r\n\t\"#ffff00\",\r\n\t\"#ff00ff\",\r\n\t\"#000000\"\r\n];\r\nconst LABEL_FONT = \"Arial\";\r\n// the ratio of the font size to the cell side length\r\nconst FONT_CELL_RATIO = 0.5;\r\n\r\n// assets\r\nconst SVGNS = \"http://www.w3.org/2000/svg\";\r\nconst BOMB_IMAGE_LOC = \"./assets/raincloud.svg\";\r\nconst FLAG_IMAGE_LOC= \"./assets/umbrella-alt.svg\";\r\n\r\n\r\n\r\nconst incBombs = new Event(\"incBombs\");\r\nconst decBombs = new Event(\"decBombs\");\r\nconst incNumMapped = new Event(\"incNumMapped\");\r\nconst decNumMapped = new Event(\"decNumMapped\")\r\n\r\n\r\nfunction regularPoly(x,y,angle,numSides,side) {\r\n\t/*\r\n\t\treturns the coordinates of the veritces of a regular polygon\r\n\t\t\t(Number,Number) x,y: the coordinates of one vertex of the\r\n\t\t\t\tpolygon\r\n\t\t\t(Number) angle: the clockwise angle one side at (x,y) makes\r\n\t\t\t\twith the positive x-axis\r\n\t\t\t(Number/Integer) numSides: the number of sides of the polygon\r\n\t\t\t(Number) side: the side length of the polygon\r\n\t*/\r\n\tlet tmpx = x, tmpy = y;\r\n\tlet vertices = \"\";\r\n\tfor(let i=0; i<numSides; ++i) {\r\n\t\tvertices += `${tmpx},${tmpy}`;\r\n\t\tif(i<numSides-1)\r\n\t\t\tvertices += \" \";\r\n\t\ttmpx += side*Math.cos(angle + i*2*Math.PI/numSides);\r\n\t\ttmpy += side*Math.sin(angle + i*2*Math.PI/numSides);\r\n\t}\r\n\treturn vertices;\r\n}\r\n\r\n\r\n\r\nclass RegularCell {\r\n\tconstructor(svgcanvas,x,y,angle,numSides,boundSide) {\r\n\t\t/*\r\n\t\t\t(Reference to SVG element) svgcanvas: the svg element the cell\r\n\t\t\t\twill be drawn in\r\n\t\t\t(Number) x: the x-coordinate of the topmost and leftmost vertex\r\n\t\t\t\tof the polygon\r\n\t\t\t(Number) y:  the y-coordinate of the topmost and leftmost \r\n\t\t\t\tvertex of the polygon\r\n\t\t\t(Number) angle: the angle (in radians) that the baseline (the \r\n\t\t\t\tfirst side fo the polygon to be drawn) makes with the horizontal\r\n\t\t\t(Number/int) numSides: the number of sides of the polygon representing\r\n\t\t\t\tthe cell\r\n\t\t\t(Number) boundSide: the side length of the \"bounding shape\" of the cell\r\n\t\t\t\tThe \"bounding shape\" here is just a slightly larger copy of the cell\r\n\t\t\t\tshape used to give some padding between cells.\r\n\t\t*/\r\n\t\t// ++++++++++++ creating the actual cell shape ++++++++++++\r\n\t\tlet boundShape = document.createElementNS(SVGNS,\"polygon\");\r\n\t\tlet cellShape = document.createElementNS(SVGNS,\"polygon\");\r\n\t\t\r\n\t\tthis.cellSide = boundSide * (1 - 2*PADDING*Math.sin(Math.PI/numSides));\r\n\t\t\r\n\t\tboundShape.setAttribute(\r\n\t\t\t\"points\",\r\n\t\t\tregularPoly(x,y,angle,numSides,boundSide)\r\n\t\t);\r\n\t\tcellShape.setAttribute(\r\n\t\t\t\"points\",\r\n\t\t\tregularPoly(\r\n\t\t\t\tx + boundSide * PADDING * Math.sin(Math.PI/numSides - angle),\r\n\t\t\t\ty + boundSide * PADDING * Math.cos(Math.PI/numSides - angle),\r\n\t\t\t\tangle,\r\n\t\t\t\tnumSides,\r\n\t\t\t\tthis.cellSide\r\n\t\t\t)\r\n\t\t);\r\n\t\tboundShape.setAttribute(\"fill\",PADDING_COLOUR);\r\n\t\tcellShape.setAttribute(\"fill\",UNREVEALED_COLOUR);\r\n\t\t\r\n\t\tthis.boundShape = boundShape;\r\n\t\tthis.cellShape = cellShape;\r\n\t\tthis.boundSide = boundSide;\r\n\t\tthis.numSides = numSides;\r\n\t\tthis.svgcanvas = svgcanvas;\r\n\t\t\r\n\t\t// ++++++++++++ geometric properties of the cell ++++++++++++\r\n\t\t// (for positioning stuff on the cell, such as the flag) \r\n\t\tthis.centreX = x + (boundSide * Math.sin(Math.PI/numSides - angle)) /\r\n\t\t\t(2 * Math.sin(Math.PI/numSides));\r\n\t\tthis.centreY = y + (boundSide * Math.cos(Math.PI/numSides - angle)) /\r\n\t\t\t(2 * Math.sin(Math.PI/numSides));\r\n\t\tthis.radius = this.cellSide / Math.tan(Math.PI/numSides);\r\n\t\t\r\n\t\t// ++++++++++++ Cell Properties (to be reset later) ++++++++++++\r\n\t\tthis.isBomb = false;\r\n\t\tthis.numAdjBombs = 0;\r\n\t\tthis.isRevealed = false;\r\n\t\tthis.isFlagged = false;\r\n\t\t\r\n\t\t// ++++++++++++ the flag ++++++++++++\r\n\t\tthis.flagImage = document.createElementNS(SVGNS,\"image\");\r\n\t\tthis.flagImage.setAttribute(\r\n\t\t\t\"x\",\r\n\t\t\t(this.centreX - 0.5*this.radius).toString()\r\n\t\t);\r\n\t\tthis.flagImage.setAttribute(\r\n\t\t\t\"y\",\r\n\t\t\t(this.centreY - 0.5*this.radius).toString()\r\n\t\t);\r\n\t\tthis.flagImage.setAttribute(\"width\",this.radius.toString());\r\n\t\tthis.flagImage.setAttribute(\"height\",this.radius.toString());\r\n\t\tthis.flagImage.setAttribute(\"href\",FLAG_IMAGE_LOC);\r\n\t\t\r\n\t\t// ++++++++++++ add event listeners ++++++++++++\r\n\t\tthis.cellShape.addEventListener(\r\n\t\t\t\"click\",\r\n\t\t\tevent => {\r\n\t\t\t\tif(event.button === 0) {\r\n\t\t\t\t\tthis.reveal();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\tthis.cellShape.addEventListener(\r\n\t\t\t\"contextmenu\",\r\n\t\t\tevent => {\r\n\t\t\t\tthis.toggleFlag(event);\r\n\t\t\t}\r\n\t\t);\r\n\t\tthis.flagImage.addEventListener(\r\n\t\t\t\"contextmenu\",\r\n\t\t\tevent => {\r\n\t\t\t\tthis.toggleFlag(event);\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// ++++++++++++ add this cell to the svg element ++++++++++++\r\n\t\tsvgcanvas.appendChild(boundShape);\r\n\t\tsvgcanvas.appendChild(cellShape);\r\n\t}\r\n\t\r\n\tsetBomb() {\r\n\t\tthis.isBomb = true;\r\n\t}\r\n\t\r\n\tincNumAdjBombs() {\r\n\t\t++this.numAdjBombs;\r\n\t}\r\n\t\r\n\ttoggleFlag(event) {\r\n\t\tevent.preventDefault();\r\n\t\tif(this.isRevealed) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(this.isFlagged) {\r\n\t\t\tdocument.dispatchEvent(incBombs);\r\n\t\t\tdocument.dispatchEvent(decNumMapped);\r\n\t\t\tthis.svgcanvas.removeChild(this.flagImage);\r\n\t\t} else {\r\n\t\t\tdocument.dispatchEvent(decBombs);\r\n\t\t\tdocument.dispatchEvent(incNumMapped);\r\n\t\t\tthis.svgcanvas.appendChild(this.flagImage);\r\n\t\t}\r\n\t\tthis.isFlagged = !this.isFlagged;\r\n\t}\r\n\t\r\n\treveal() {\r\n\t\tif(this.isFlagged)\r\n\t\t\treturn;\r\n\t\tif(this.isRevealed)\r\n\t\t\treturn;\r\n\t\tthis.isRevealed = true;\r\n\t\tdocument.dispatchEvent(incNumMapped);\r\n\t\tif(this.isBomb) {\r\n\t\t\tdocument.dispatchEvent(decBombs);\r\n\t\t\tthis.cellShape.setAttribute(\"opacity\",BOMB_OPACITY);\r\n\t\t\tlet bombImage = document.createElementNS(SVGNS,\"image\");\r\n\t\t\tbombImage.setAttribute(\r\n\t\t\t\t\"x\",\r\n\t\t\t\t(this.centreX - 0.5*this.radius).toString()\r\n\t\t\t);\r\n\t\t\tbombImage.setAttribute(\r\n\t\t\t\t\"y\",\r\n\t\t\t\t(this.centreY - 0.5*this.radius).toString()\r\n\t\t\t);\r\n\t\t\tbombImage.setAttribute(\"width\",this.radius.toString());\r\n\t\t\tbombImage.setAttribute(\"height\",this.radius.toString());\r\n\t\t\tbombImage.setAttribute(\"href\",BOMB_IMAGE_LOC);\r\n\t\t\tthis.svgcanvas.appendChild(bombImage);\r\n\t\t} else {\r\n\t\t\tlet label = document.createElementNS(SVGNS,\"text\");\r\n\t\t\tlet labelColour;\r\n\t\t\tif(this.numAdjBombs < LABEL_COLOURS.length) {\r\n\t\t\t\tlabelColour = LABEL_COLOURS[this.numAdjBombs];\r\n\t\t\t} else {\r\n\t\t\t\tlabelColour = LABEL_COLOURS[LABEL_COLOURS.length-1];\r\n\t\t\t}\r\n\t\t\tlabel.setAttribute(\"fill\",labelColour);\r\n\t\t\tlabel.setAttribute(\"x\",this.centreX.toString());\r\n\t\t\tlabel.setAttribute(\"y\",this.centreY.toString());\r\n\t\t\tlabel.setAttribute(\"text-anchor\",\"middle\");\r\n\t\t\tlabel.setAttribute(\"dominant-baseline\",\"middle\");\r\n\t\t\tlabel.setAttribute(\r\n\t\t\t\t\"font-size\",\r\n\t\t\t\tMath.ceil(this.cellSide*FONT_CELL_RATIO).toString()\r\n\t\t\t);\r\n\t\t\tlabel.setAttribute(\"font-family\",LABEL_FONT);\r\n\t\t\tlet labelText = document.createTextNode(this.numAdjBombs.toString());\r\n\t\t\tlabel.appendChild(labelText);\r\n\t\t\tthis.svgcanvas.appendChild(label);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\nconst exports = {\r\n\t\"SVGNS\":SVGNS,\r\n\t\"RegularCell\": RegularCell\r\n}\r\n\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);\r\n\n\n//# sourceURL=webpack:///./src/Cell.js?");

/***/ }),

/***/ "./src/Mode.js":
/*!*********************!*\
  !*** ./src/Mode.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Board.js */ \"./src/Board.js\");\n// This module is just a list of game modes of RainSweeper\r\n\r\n\r\nconst root2 = Math.sqrt(2);\r\nconst root3 = Math.sqrt(3);\r\nconst root75 = Math.sqrt(.75);\r\n\r\n\r\nconst sqOctInfo = [\r\n\t{x:0, y:0, angle:0, numSides:8},\r\n\t{x:1+0.5*root2, y:0.5*root2, angle:0, numSides:4},\r\n\t{x:0, y:1+root2, angle:0, numSides:4},\r\n\t{x:1+0.5*root2, y:1+0.5*root2, angle:0, numSides:8}\r\n];\r\nconst squareAndOctagon = new _Board_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CellGroup(sqOctInfo,2+root2,2+root2,1);\r\n\r\nconst hexInfo = [\r\n\t{x:0, y:0, angle:0, numSides:6},\r\n\t{x:1.5, y:root75, angle:0, numSides:6}\r\n];\r\nconst hexGroup = new _Board_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CellGroup(hexInfo,3,2*root75,0.8);\r\n\r\nconst triInfo = [\r\n\t{x:0, y:0, angle:0.0, numSides:3},\r\n\t{x:0.5, y:root75, angle:-Math.PI/3, numSides:3},\r\n\t{x:0.5, y:root75, angle:0.0, numSides:3},\r\n\t{x:0.5, y:root75, angle:Math.PI/3, numSides:3}\r\n];\r\nconst triGroup = new _Board_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CellGroup(triInfo,1,2*root75,0.6);\r\n\r\nconst hexStarInfo = [\r\n\t{x:0, y:0, angle:0.0, numSides:3},\r\n\t{x:1, y:0, angle:0.0, numSides:6},\r\n\t{x:0.5, y:root75, angle:Math.PI/3, numSides:3},\r\n\t{x:0, y:2*root75, angle:0.0, numSides:6},\r\n\t{x:1, y:2*root75, angle:0.0, numSides:3},\r\n\t{x:1.5, y:3*root75, angle:Math.PI/3, numSides:3}\r\n]\r\nconst hexStarGroup = new _Board_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CellGroup(hexStarInfo,2,4*root75,0.6);\r\n\r\nconst twelvePointInfo = [\r\n\t{x:0, y:0, angle:0.0, numSides:12},\r\n\t{\r\n\t\tx: (0.5 * (2+root3)),\r\n\t\ty: (0.5 * (3+2*root3)),\r\n\t\tangle: 0.0,\r\n\t\tnumSides: 4\r\n\t},\r\n\t{\r\n\t\tx: (0.5 * (3+root3)),\r\n\t\ty: (0.5 * (3+root3)),\r\n\t\tangle: Math.PI/3,\r\n\t\tnumSides: 3\r\n\t},\r\n\t// {\r\n\t// \tx: (0.5 * (4+root3)),\r\n\t// \ty: (0.5 * (3+2*root3)),\r\n\t// \tangle: Math.PI/6,\r\n\t// \tnumSides: 3\r\n\t// },\r\n\t{x: (0.5 * (2+root3)),\r\n\t\ty: (0.5 * (5+2*root3)),\r\n\t\tangle: 0.0,\r\n\t\tnumSides: 3\r\n\t},\r\n\t{\r\n\t\tx: (0.5 * (2+root3)),\r\n\t\ty: (0.5 * (3+2*root3)),\r\n\t\tangle: Math.PI/2,\r\n\t\tnumSides: 3\r\n\t},\r\n\t{\r\n\t\tx: (-0.5 * root3),\r\n\t\ty: (0.5 * (3+2*root3)),\r\n\t\tangle: Math.PI/6,\r\n\t\tnumSides: 3\r\n\t}\r\n];\r\nconst twelvePointGroup = new _Board_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CellGroup(twelvePointInfo,2+root3,2+root3,1.5);\r\n\r\n\r\nconst exports = {\r\n\t\"Squares & Octagons\": {\r\n\t\t\"groupType\":squareAndOctagon,\r\n\t\t\"sizes\": [[3,3],[3,4],[4,4],[4,6],[5,5]]\r\n\t},\r\n\t\"All Hexagons\": {\r\n\t\t\"groupType\": hexGroup,\r\n\t\t\"sizes\": [[3,3],[5,5],[6,6],[10,10],[12,15]]\r\n\t},\r\n\t\"All Triangles\": {\r\n\t\t\"groupType\": triGroup,\r\n\t\t\"sizes\": [[5,5],[10,10],[20,15]]\r\n\t},\r\n\t\"The Six-Pointed Star\": {\r\n\t\t\"groupType\": hexStarGroup,\r\n\t\t\"sizes\": [[3,4],[3,5],[3,6],[5,7]]\r\n\t},\r\n\t\"The Twelve-Pointed Star\": {\r\n\t\t\"groupType\": twelvePointGroup,\r\n\t\t\"sizes\": [[3,3],[3,5],[5,7],[5,10]]\r\n\t}\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);\r\n\n\n//# sourceURL=webpack:///./src/Mode.js?");

/***/ }),

/***/ "./src/Sweeper-main.js":
/*!*****************************!*\
  !*** ./src/Sweeper-main.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Cell_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell.js */ \"./src/Cell.js\");\n/* harmony import */ var _Board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Board.js */ \"./src/Board.js\");\n/* harmony import */ var _Mode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Mode.js */ \"./src/Mode.js\");\n\r\n\r\n\r\n\r\nconst CELL_SIZE = 40;\r\nconst DEFAULT_NUM_BOMBS = 16;\r\nconst DEFAULT_ROWS = 4;\r\nconst DEFAULT_COLS = 6;\r\nconst DEFAULT_MODE = \"Squares & Octagons\";\r\n\r\n\r\n// ++++++++++++ INDICATORS ++++++++++++\r\n\t// +++ Note +++\r\n\t// This section uses some magic numbers. This is because any changes\r\n\t// made to this part in the future will likely involve refactoring how the \r\n\t// code itself works, meaning any constants would need to be changed anyway.\r\n\r\n//  percentage of cells revealed indicator \r\nlet numMapped = 0, totalCells;\r\nfunction mappedFormat() {\r\n\tlet pc = Math.trunc((numMapped/totalCells) * 100);\r\n\treturn pc.toString().concat(\"%\");\r\n}\r\nlet pcMappedLabel = document.createTextNode(mappedFormat());\r\ndocument.getElementById(\"pcMapped-state\").appendChild(pcMappedLabel);\r\ndocument.addEventListener(\r\n\t\"incNumMapped\",\r\n\t(evt) => {\r\n\t\t++numMapped;\r\n\t\tpcMappedLabel.nodeValue = mappedFormat();\r\n\t\tif(game.isWon()) {\r\n\t\t\talert(\"You Win!\\nYou can start a new game using the menu above\");\r\n\t\t}\r\n\t}\r\n);\r\ndocument.addEventListener(\r\n\t\"decNumMapped\",\r\n\t(evt) => {\r\n\t\t--numMapped;\r\n\t\tpcMappedLabel.nodeValue = mappedFormat();\r\n\t}\r\n);\r\n\t\t\r\n\r\n//  current number of bombs indicator \r\nlet numBombs = 0;\r\nfunction bombsFormat() {\r\n\t// returns the string to be used as the current number of bombs\r\n\t// indicator\r\n\tlet numAsStr = Math.abs(numBombs).toString();\r\n\treturn \"\".concat(\r\n\t\tnumBombs < 0 ? \"-\":\" \",\r\n\t\tnumAsStr\r\n\t);\r\n}\r\nlet numBombsLabel = document.createTextNode(bombsFormat());\r\ndocument.getElementById(\"numBombs-state\").appendChild(numBombsLabel);\r\ndocument.addEventListener(\r\n\t\"incBombs\",\r\n\t(evt) => {\r\n\t\t++numBombs;\r\n\t\tnumBombsLabel.nodeValue = bombsFormat();\r\n\t}\r\n);\r\ndocument.addEventListener(\r\n\t\"decBombs\",\r\n\t(evt) => {\r\n\t\t--numBombs;\r\n\t\tnumBombsLabel.nodeValue =  bombsFormat();\r\n\t}\r\n);\r\n\r\n\r\n\r\n// ++++++++++++ CREATE NEW GAME (SELECTORS) ++++++++++++\r\n//  mode selector \r\nconst modeSelector = document.getElementById(\"Mode-Selector\");\r\nlet option, optionName;\r\nfor(const modeName in _Mode_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\r\n\toption = document.createElement(\"option\");\r\n\toptionName = document.createTextNode(modeName);\r\n\toption.appendChild(optionName);\r\n\tmodeSelector.appendChild(option);\r\n}\r\n\r\n//  board size selector \r\nconst sizeSelector = document.getElementById(\"size-Selector\");\r\nmodeSelector.addEventListener(\"change\",updateSizeSelector);\r\nfunction updateSizeSelector(evt) {\r\n\twhile(sizeSelector.children.length > 0)\r\n\t\tsizeSelector.children[0].remove();\r\n\tlet option, optionName, numCellsInOption;\r\n\tfor(let dims of _Mode_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][modeSelector.value].sizes) {\r\n\t\toption = document.createElement(\"option\");\r\n\t\tnumCellsInOption = \r\n\t\t\tdims[0]*dims[1]*_Mode_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][modeSelector.value].groupType.numCells;\r\n\t\toptionName = document.createTextNode(`${numCellsInOption} clouds`);\r\n\t\toption.value = dims;\r\n\t\toption.appendChild(optionName);\r\n\t\tsizeSelector.appendChild(option);\r\n\t}\r\n}\r\n\r\n//  number of bombs selector\r\nconst numBombsInput = document.getElementById(\"numBombs-Selector\");\r\nfunction updateNumBombsInput(evt) {\r\n\tlet maxCells = sizeSelector.value\r\n\t\t.split(\",\")\r\n\t\t.map((x)=>parseInt(x))\r\n\t\t.reduce(\r\n\t\t\t(acc,entry) => acc * entry,\r\n\t\t\t1\r\n\t\t)\r\n\t\t* _Mode_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][modeSelector.value].groupType.numCells;\r\n\tnumBombsInput.max = maxCells.toString();\r\n\tnumBombsInput.value = Math.round(maxCells/6);\r\n}\r\nsizeSelector.addEventListener(\"change\",updateNumBombsInput);\r\nmodeSelector.addEventListener(\"change\",updateNumBombsInput);\r\n\r\n\r\n//  new game button \r\nlet svgcanvas, game;\r\ndocument.getElementById(\"New-Game\").addEventListener(\r\n\t\"click\",\r\n\t(evt) => {\r\n\t\t// get rid of existing game\r\n\t\tif(svgcanvas !== undefined)\r\n\t\t\tsvgcanvas.remove();\r\n\t\tsvgcanvas = document.createElementNS(_Cell_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGNS,\"svg\");\r\n\t\t\r\n\t\t// actually make the game\r\n\t\tconst dims = sizeSelector.value.split(\",\").map((x) => parseInt(x));\r\n\t\tgame = new _Board_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Board(\r\n\t\t\tsvgcanvas,\r\n\t\t\tCELL_SIZE,\r\n\t\t\t_Mode_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][modeSelector.value].groupType,\r\n\t\t\tdims[0],dims[1],\r\n\t\t\tparseInt(numBombsInput.value)\r\n\t\t);\r\n\t\t\r\n\t\t// set initial indicator values\r\n\t\tnumBombs = parseInt(numBombsInput.value);\r\n\t\tnumBombsLabel.nodeValue = bombsFormat();\r\n\t\ttotalCells = game.cells.length;\r\n\t\tnumMapped = 0;\r\n\t\tpcMappedLabel.nodeValue = mappedFormat();\r\n\t\t\r\n\t\t// add the game to the DOM\r\n\t\tsvgcanvas.setAttribute(\"height\",game.height.toString());\r\n\t\tsvgcanvas.setAttribute(\"width\",game.width.toString());\r\n\t\tdocument.getElementById(\"game-container\").appendChild(svgcanvas);\r\n\t}\r\n);\r\n\r\n\r\n// ++++++++++++ CREATE DEFAULT GAME ++++++++++++\r\n// (i.e. the version the user will see loading the website)\r\nsvgcanvas = document.createElementNS(_Cell_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGNS,\"svg\");\r\ngame = new _Board_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Board(\r\n\tsvgcanvas,\r\n\tCELL_SIZE,\r\n\t_Mode_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][DEFAULT_MODE].groupType,\r\n\tDEFAULT_ROWS,DEFAULT_COLS,\r\n\tDEFAULT_NUM_BOMBS\r\n);\r\n\r\nnumBombs = DEFAULT_NUM_BOMBS;\r\nnumBombsLabel.nodeValue = bombsFormat();\r\ntotalCells = game.cells.length;\r\npcMappedLabel.nodeValue = mappedFormat();\r\n\r\nsvgcanvas.setAttribute(\"height\",game.height.toString());\r\nsvgcanvas.setAttribute(\"width\",game.width.toString());\r\ndocument.getElementById(\"game-container\").appendChild(svgcanvas);\r\n\n\n//# sourceURL=webpack:///./src/Sweeper-main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/Sweeper-main.js");
/******/ 	
/******/ })()
;